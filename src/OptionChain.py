import os
from datetime import datetime
import numpy as np

from ib_insync import IB, Contract, Option, BarDataList

from src.BSMRootFinder import BSMRootFinder
from src.utils import expiryStrToDate, getOCCKey, saveObject, loadObject


class OptionChain:

    '''
    Andrew W.E. McDonald, 2021-12-11

    Code to request and initially process option chain from IB from: https://nbviewer.org/github/erdewit/ib_insync/blob/master/notebooks/option_chain.ipynb
    '''

    def __init__(me, ib: IB, underlyingContract: Contract):
        me.ib = ib
        me.optionChainBasePath = "./resources/data/oc/"
        me.optionChainPricesBasePath = "./resources/data/oc_prices_2021_12_10_hourly_bars_1_day/"
        me.underlyingContract = underlyingContract
        me.chain = None
        me.exchange = "CBOE"
        me.ocContracts = {}
        me.ocContractsBarDataLists = {}
        me.daysToExpiryList = []
        me.expiriesDates = []

    def calculateIVs(me, right: str, r: float):
        '''
        This function uses the BSMRootFinder to calculate the implied volatilities of the options contracts,
        using the BlackScholesMerton class to price them.

        IVs are put into the ivMatrix 2D numpy array, where the rows are the strikes,
        and columns are expiries.

        :param right: 'P' or 'C' for put or call.
        :param r: risk free rate, as a decimal, not percent.
        :return: ivMatrix
        '''
        numExpiries = len(me.expiriesDates)
        numStrikes = len(me.strikes)
        print(f"Starting on {numExpiries} x {numStrikes} = {numExpiries*numStrikes} IV calculations...")
        ivMatrix = np.zeros((numStrikes, numExpiries))
        underlyingPrice = np.mean([bar.close for bar in me.underlyingBarDataList])
        brf = BSMRootFinder()
        numCalcuations = 0
        totalCalculations = numExpiries * numStrikes
        for expiryIdx in range(numExpiries):
            expiryDate = me.expiriesDates[expiryIdx]
            for strikeIdx in range(numStrikes):
                strike = me.strikes[strikeIdx]
                daysToExpiry = me.daysToExpiryList[expiryIdx]
                ocContractKey = getOCCKey(strike, right, expiryDate)
                ocContract = me.ocContracts.get(ocContractKey, None)
                barDataList = me.ocContractsBarDataLists.get(ocContractKey, None)
                if barDataList is None or len(barDataList) == 0:
                    print(f"Error retrieving option contract: {strike} {right} {expiryDate}")
                else:
                    try:
                        mrbCloseAvg = np.mean([bar.close for bar in barDataList])# Call this the current price of the option
                    except IndexError as ie:
                        continue
                    yearsToExpiry = daysToExpiry/365.0
                    calculatedIV = brf.getBSIV(mrbCloseAvg, right, yearsToExpiry, underlyingPrice, strike, r)
                    ivMatrix[strikeIdx, expiryIdx] = calculatedIV
                    numCalcuations += 1
                    print(f"\rFinished {numCalcuations} of {totalCalculations} calculations (IV: {calculatedIV})")
        return ivMatrix

    def reqOptionChains(me, saveChains: bool = True):
        ''' Requests and saves option chains for the underlying contract, or loads previously saved ones. '''
        me.ticker = None
        me.underlyingContract = me.ib.qualifyContracts(me.underlyingContract)[0] # this returns a list, but we only have one contract.
        me.ticker = me.ib.reqTickers(me.underlyingContract)
        # this returns all of the option chains, across all exchanges
        optionChains = me.ib.reqSecDefOptParams(me.underlyingContract.symbol, '', me.underlyingContract.secType, me.underlyingContract.conId)

        underlyingIdx = 0
        for oc in optionChains:
            if oc.exchange == me.exchange: # Only want to save the chain from one exchange for now.
                me.chain = oc
                if saveChains:
                    # There should really be a date in the file name.
                    saveObject(oc, os.path.join(me.optionChainBasePath, f"{me.underlyingContract.symbol}_{oc.exchange}.pkl"))
        underlyingIdx += 1

    def loadOptionChain(me):
        # Need a better solution if we want to select different/additional exchanges.
        # Should have error checking here; won't worry about that for now.
        oc = loadObject(os.path.join(me.optionChainBasePath, f"{me.underlyingContract.symbol}_{me.exchange}.pkl"))
        me.chain = oc

    def createOptionContracts(me, reqNewData: bool):
        '''
        This creates option contracts from the option chain.
        Contracts are put into the .ocContracts dictionary, keyed by the key generated by .getOCCKey(strike, right, expiration)

        This function also qualifies (validates) the contracts with IB,
        and then loads data for them.
        It also does this with/for the underlying.

        Ideally, this function wouldn't do quite as much as it does; it's fine for now though.
        :return:
        '''
        if reqNewData:
            now = datetime.now()
            histData: BarDataList = me.getHistData(contract=me.underlyingContract, endDt=now)
            me.underlyingBarDataList = histData
            # print(histData)
            saveObject(histData, os.path.join(me.optionChainPricesBasePath, f"{me.underlyingContract.symbol}_midpoint.pkl"))
        else:
            me.underlyingBarDataList = loadObject(os.path.join(me.optionChainPricesBasePath, f"{me.underlyingContract.symbol}_midpoint.pkl"))
        underlyingValue = me.underlyingBarDataList[-1].close

        # Get strikes by fives within 12% of the underlying (IB was missing a contract or two for 15%)
        strikeMin = underlyingValue * .87
        strikeMax = underlyingValue * 1.12
        me.strikes = [strike for strike in me.chain.strikes if strike % 5 == 0
                   and strikeMin < strike < strikeMax] # Need to stay close to strike
        me.expiriesStrs = sorted(expiry for expiry in me.chain.expirations)[:12] # Just get the first 12
        me.expiriesDates = [expiryStrToDate(expiry) for expiry in me.expiriesStrs]
        # Note: uncomment this to load puts
        #me.rights = ['P', 'C']
        me.rights = ['C',]

        optionContracts = [Option(me.underlyingContract.symbol, expiry, strike, right, exchange=me.exchange)
                     for right in me.rights
                     for expiry in me.expiriesStrs
                     for strike in me.strikes]

        #contracts = ib.qualifyContracts(*contracts)
        me.ocContractsBarDataLists = {}
        numIndexErrors = 0
        contractNumber = 0
        numContracts = len(optionContracts)
        for optionContract in optionContracts:
            contractNumber += 1
            try:
                optionContract = me.ib.qualifyContracts(optionContract)[0] # Qualifying 1 contract at a time for now, but a list is returned; extract the first (and only) element.
            except IndexError as ie: # Couldn't qualify the contract, so just move on.
                # Note: These errors just mean the broker doesn't have a contract for the specific strike, date, and right combination. Ignore them.
                numIndexErrors += 1
                continue
            strike = optionContract.strike
            right = optionContract.right
            expiry = expiryStrToDate(optionContract.lastTradeDateOrContractMonth)
            ocKey = getOCCKey(strike, right, expiry)
            print(f"Getting data for contract {contractNumber} of {numContracts} (key: {ocKey})")
            me.ocContracts[ocKey] = optionContract
            #print(optionContract)
            # Either get new data and save it, or load the historic data we need.
            if reqNewData:
                now = datetime.now()
                histData: BarDataList = me.getHistData(contract=optionContract, endDt=now)
                me.ocContractsBarDataLists[ocKey] = histData
                #print(histData)
                saveObject(histData, os.path.join(me.optionChainPricesBasePath, f"{ocKey}_midpoint.pkl"))
            else:
                me.ocContractsBarDataLists[ocKey] = loadObject(os.path.join(me.optionChainPricesBasePath, f"{ocKey}_midpoint.pkl"))
            #if len(me.ocContracts) > 100:
            #    break

        # Note: These errors just mean the broker doesn't have a contract for the specific strike, date, and right combination. Ignore them.
        print(f"Encountered {numIndexErrors} errors when attempting to qualify {len(optionContracts)} contracts.")

    def getDaysToExpiry(me):
        '''
        We don't need to use the market calendar unless we want trading days to expiry.
        The convention seems to be calendar days though, so we'll go with that for now.

        The trading days with market calendar approach hasn't been fully implemented yet;
        I stopped midway through when I realized calendar days should work.
        :return:
        '''
        #marketCalendar = MarketCalendar()
        # This is a stupid way to get a single contract.
        #ocKeys = oc.ocContracts.keys()
        #for ocKey in ocKeys:
        #    marketCalendar.createCalendarByContract(oc.ocContracts[ocKey])
        #    break
        #now = datetime.now()
        #lastDt = oc.expiries[-1]  # get the expiry of the last contract
        #marketCalendar.createSchedule(scheduleStartDatetimeTz=now, scheduleEndDatetimeTz=lastDt)
        #nextOpenDt, _, _ = marketCalendar.getNextOpenAfter(now)
        now = datetime.now().date()
        for expiry in me.expiriesDates:
            timedeltaToExpiry = expiry - now
            me.daysToExpiryList.append(timedeltaToExpiry.days)

    def getHistData(me, contract: Contract, endDt: datetime):
        ''' Just a wrapper to make sure any parameter changes are reflected across all requests. '''
        histData: BarDataList = me.ib.reqHistoricalData(contract=contract, endDateTime=endDt, durationStr="1 D", barSizeSetting='1 hour', whatToShow="MIDPOINT", useRTH=True)
        return histData
